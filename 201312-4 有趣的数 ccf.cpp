/*
考察点是动态规划
题目给出了0，1，2，3四个数，现考察一系列中间状态，即选取四个数的子集，在满足题设条件下，共有如下6种状态
状态0：2 
状态1：0 2 
状态2：2 3 
状态3：0 1 2 
状态4：0 2 3 
状态5：0 1 2 3 
最终我们需要求得的结果是状态5，用sta[i][j]表示一系列中间过程，其中i表示数的位数，j表示状态
显然，i=0时，所有的不同结果都为0（边界条件）
对于状态0来说，所选取的集合只有2，所以对于任意数位n，其不同个数始终为1
对于状态1来说，数位为i时的结果可以通过第i-1位状态获得，包括
			  (1)通过状态0获得，只能在第i位时添加0，即sta[i-1][0]
			  (2)通过本身状态1获得，在第i位添加0或者2，即sta[i-1][1]*2
			  所以，sta[i][1]=sta[i-1][0]+sta[i-1][1]*2
对于状态2来说，数位为i时的结果可以通过第i-1位状态获得，包括
			  (1)通过状态0获得，只能在第i位时添加3，即sta[i-1][0]
			  (2)通过本身状态2获得，只能在第i位添加3，即sta[i-1][2]
			  所以，sta[i][2]=sta[i-1][0]+sta[i-1][2]
其余状态同理，也即是，对于任意状态，总可以通过前序状态或者本身状态获得
所有转移方程如下
sta[i][0]=1
sta[i][1]=sta[i-1][0]+sta[i-1][1]*2
sta[i][2]=sta[i-1][0]+sta[i-1][2]
sta[i][3]=sta[i-1][1]+sta[i-1][3]*2
sta[i][4]=sta[i-1][1]+sta[i-1][2]+sta[i-1][4]*2
sta[i][5]=sta[i-1][3]+sta[i-1][4]+sta[i-1][5]*2

对状态的补充：
一个数情况，必须是2（首位必须是2）
		   (0)2
两个数情况，必须有2，其余只能是0，3（0必须在1前面）
		   (1)0 2
		   (2)2 3
三个数情况，必须有2，其余可能是0，1或者0，3
		   (3)0 1 2
		   (4)0 2 3
四个数情况，(5)0 1 2 3
6种状态整理完毕
*/
#include <bits/stdc++.h>
using namespace std;
typedef long long llt;
const llt mod=1000000007;
llt sta[1024][6],n;
int main()
{
	scanf("%lld",&n);
	for(llt i=1;i<=n;++i)
	{
		sta[i][0]=1;
		sta[i][1]=(sta[i-1][0]+sta[i-1][1]*2)%mod;
		sta[i][2]=(sta[i-1][0]+sta[i-1][2])%mod;
		sta[i][3]=(sta[i-1][1]+sta[i-1][3]*2)%mod;
		sta[i][4]=(sta[i-1][1]+sta[i-1][2]+sta[i-1][4]*2)%mod;
		sta[i][5]=(sta[i-1][3]+sta[i-1][4]+sta[i-1][5]*2)%mod;
	}
	printf("%lld\n",sta[n][5]);
	return 0;
}
